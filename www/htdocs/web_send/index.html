<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>web_send: Browser shell for JSON resources</title>
<link rel="StyleSheet" type="text/css" href="../site/style.css">
<link rel="icon" type="image/gif" href="../site/icon.gif">
<link rel="alternate" type="application/atom+xml" title="Atom (news summaries)" href="../recent.xml">
</head>
<body>
<div class="navigation heading">
<a href="../"><img alt="home" src="../site/icon.gif" width="16" height="16"></a>
&rarr; <a class="heading" href="./">web_send</a>
</div>
<div class="main">
<a href="https://waterken.svn.sourceforge.net/svnroot/waterken/server/trunk/waterken/config/file/site/">SVN URL</a>,
<a href="../bang/">Bang Tutorial</a>

<h1><a name="title" href="#title">Browser shell for JSON resources</a></h1>
<p>Not so long ago, in less constrained times, the self-sufficient programmer
would design a simple text string protocol for interacting with a server-side
program. A basic telnet program was then all that was needed to test
server-side code during development: write some code, launch the server, poke
and prod it from the telnet session to make sure it does what you want. Today,
such ingenuity at the protocol layer is lost to us, forbidden by our firewalls.
Woe unto the server-side developer.</p>
<p>If we are willing to embrace our web browser overlord, we can regain that
lost productivity, plus some extra.  Since the browser provides us with a full
programming language (JavaScript) and a console (<a title="Firefox addon page"
href="https://addons.mozilla.org/firefox/addon/1843">Firebug</a>), we can turn
it into a command-line interpreter for the server-side code. With such a tool
we could hold onto and reuse server responses using actual variables, instead
of copying and pasting text!  All we need is a library with an easy syntax for
generating HTTP requests. The web_send library is that library: providing a
remote promise API for HTTP URLs. A promise is a special kind of reference that
lets you easily work with objects that you only have asynchronous access to,
such as remote objects.</p>

<h2><a name="quickStart" href="#quickStart">Some quick introductory examples</a></h2>
<p>For example, say you've got a brand new server-side object sitting at a URL
like: <code>&lt;https://example.com/myApp/obj123&gt;</code>. All you want to do
is invoke one of its methods, to see what happens. Using the web_send library
from the Firebug console, you could write:</p>
<pre>
maker = lib.web.getLocation();
drum = lib.Q.post(maker, 'makeDrum', []);
</pre>
<p>That code generates the following HTTP request:</p>
<pre>
POST /myApp/obj123?q=makeDrum HTTP/1.1
Host: example.com
Content-Type: text/plain; charset=UTF-8
Content-Length: 2

[]
</pre>
<p>The arguments to <code>Q.post()</code> are:</p>
<ol>
<li>promise for the target object</li>
<li>optional argument to add to the query string</li>
<li>optional JSON array for the request body</li>
</ol>
<p>The <code>makeDrum()</code> method didn't take any arguments. Here's one
that does:</p>
<pre>
lib.Q.post(drum, 'bang', [ 1 ]);
</pre>
<p>Causing the HTTP request:</p>
<pre>
POST /myApp/obj456?q=bang HTTP/1.1
Host: example.com
Content-Type: text/plain; charset=UTF-8
Content-Length: 5

[ 1 ]
</pre>
<p>The target URL in the above request was taken from the HTTP response to the
previous request. For this to work, the web_send library introduces some
conventions for HTTP requests and responses. These conventions are the least
restrictive they can be, while still supporting the client-side promise API.
The rest of this document explains these conventions.</p>

<h2><a name="JSON" href="#JSON">JSON conventions</a></h2>
<p>The web_send library can generate an HTTP request entity using JSON and
extract information from the JSON in an HTTP response. Doing so requires a
few conventions.</p>

<h3><a name="JSONlink" href="#JSONlink">JSONlink</a></h3>
<p>In the introductory example, one of the requests was sent on a promise
derived from a previous HTTP response. For this to work, the web_send library
needs to know where to find the corresponding URL inside the HTTP response. To
enable this, represent a URL as a JSON object having a single member named
<code>"@"</code>, whose value is the URL string. For example, the JSON response entity in the introductory example was:</p>
<pre>
{ "@" : "obj456" }
</pre>
<p>The provided URL will be interpreted relative to the Request-URI.  In this
case, the base URL was
<code>&lt;https://example.com/myApp/obj123?q=makeDrum&gt;</code>,
making the resolved URL
<code>&lt;https://example.com/myApp/obj456&gt;</code>.</p>

<h3><a name="JSONerror" href="#JSONerror">JSONerror</a></h3>
<p>Sometimes, an invoked method will throw an exception. A thrown exception
should be encoded in JSON as:</p>
<pre>
{ "!" : "LPT1 on fire" }
</pre>
<p>The value of the <code>"!"</code> member can be any JSON value. Use it
to communicate the server method's error information. In the shown example, a
simple string is used for error information. More information can be provided
by using a JSON object:</p>
<pre>
{
  "!" : {
    "message" : "LPT1 on fire",
    "errno" : "-1",
    "stack" : "print()@42"
  }
}
</pre>
<p>Following this convention for exceptional returns enables the following
client-side error handling code:</p>
<pre>
hits = lib.Q.get(drum, 'hits');
lib.Q.when(hits, function (value) {
    // GET request successfully returned the given value
}, function (reason) {
    // GET request failed for the given reason
});
</pre>
<p>The reason passed to the error callback is the value of the <code>"!"</code>
member.</p>

<h3><a name="JSONvalue" href="#JSONvalue">JSONvalue</a></h3>
<p>Some methods only need to return a simple value, like a string or a number;
whereas <a href="http://www.ietf.org/rfc/rfc4627.txt">JSON</a> requires that a
JSON text be a JSON object or JSON array. To return a simple value, return a
JSON object with a member named <code>"="</code>, whose value is the simple
value. For example, to return the number <code>42</code>:</p>
<pre>
{ "=" : 42 }
</pre>

<h2><a name="URLref" href="#URLref">URL conventions</a></h2>
<p>When sending an HTTP request, it is often useful to include some arguments
in the Request-URI. The web_send library supports the following
conventions:</p>

<h3><a name="q" href="#q">'q' query string argument</a></h3>
<p>Both <code>Q.post()</code> and <code>Q.get()</code> take an optional string
argument. If a value is provided, it will be appended to the Request-URI's
query component as the value of the 'q' parameter (using the
<code><a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1">application/x-www-form-urlencoded</a></code>
syntax). For example, the following transformations are made for the call:</p>
<pre>
lib.Q.get(drum, 'hits');
</pre>
<table>
<tr><th>target URLref</th><th>Request-URI</th></tr>
<tr><td>/myApp/obj456</td><td>/myApp/obj456?q=hits</td></tr>
<tr><td>/myApp/?id=obj456</td><td>/myApp/?q=hits&amp;id=obj456</td></tr>
<tr><td>/myApp/?q=42</td><td>/myApp/?q=hits&amp;q=42</td></tr>
</table>

<h3><a name="fragment" href="#fragment">fragment arguments</a></h3>
<p>Sometimes, it is useful to include information in a URL that won't show up
in the HTTP protocol's Referer header, but can be made available to the server
that issued the URL. To support this, the web_send library can move information
in the URL fragment to the query component of the Request-URI. For example, for
the call:</p>
<pre>
lib.Q.get(drum, 'hits');
</pre>
<table>
<tr><th>target URLref</th><th>Request-URI</th></tr>
<tr><td>/myApp#s=obj456</td><td>/myApp?q=hits&amp;s=obj456</td></tr>
<tr><td>/myApp?id=42#s=obj456</td><td>/myApp?q=hits&amp;id=42&amp;s=obj456</td></tr>
<tr><td>/myApp?s=42#s=obj456</td><td>/myApp?q=hits&amp;s=42&amp;s=obj456</td></tr>
<tr><td>/myApp?s=42#s=obj456&amp;t=6&amp;=label</td><td>/myApp?q=hits&amp;s=42&amp;s=obj456&amp;t=6</td></tr>
</table>
<p>In the last example, the character sequence '<code>&amp;=</code>' is
recognized as terminating the part of the fragment that should be copied to the
Request-URI.</p>

<h3><a name="session" href="#session">session identifier</a></h3>
<p>Before sending any <code>POST</code> request, the web_send library will first
send a request asking the server if a session should be created. This
<code>POST</code> request is sent to the URL
<code>&lt;?q=create&amp;s=sessions&gt;</code>, resolved relative to the promise
URL that is about to be used.  If your server wishes to associate requests with
a session, respond with JSON like:</p>
<pre>
{
  "key" : "sessionid"
}
</pre>
<p>The web_send library will then include this key as the '<code>x</code>'
parameter in all <code>POST</code> requests, as well as a number
'<code>w</code>', which is incremented on each <code>POST</code> request. For
example, for the code:</p>
<pre>
lib.Q.post(drum, 'bang', [ 3 ]);
</pre>
<p>The Request-URI will be
<code>&lt;/myApp/obj456?q=bang&amp;x=sessionid&amp;w=1&gt;</code>.</p>
<p>If your server does not wish to use a session, respond to the session
creation request with a <code>404</code> response.</p>

<h3><a name="remotePromise" href="#remotePromise">server-side promise</a></h3>
<p>If your server-side code also uses promises, a URLref that refers to a
promise must be distinguished from one that refers to a direct object
reference.  Mark a URLref as referring to a promise by starting the fragment
with the text '<code>o=</code>'.  This marking is used by
<code>Q.when()</code>, which registers callbacks to be notified when a promise
is resolved. If the promise marking is present, <code>Q.when()</code> will
fetch the resolved value from the server; otherwise, it will treat the
client-side promise as the fulfilled value. For example:</p>
<pre>
var remoteProxy = &hellip; // @ https://example.com/myApp/#s=obj123
lib.Q.when(remoteProxy, function(value) {
    // value will be remoteProxy
});
var remotePromise = &hellip; // @ https://example.com/myApp/#o=&amp;s=obj123
lib.Q.when(remotePromise, function(value) {
    // value will be JSON value returned by GET request to:
    // &lt;https://example.com/myApp/?o=&amp;s=obj123&gt;
}, function(reason) {
    // or the reason the GET request failed
});
</pre>

<h2><a name="files" href="#files">Server-side files</a></h2>
<p>The code for the web_send library must be delivered to the browser by your
server. Checkout the necessary files using the subversion command:</p>
<p><kbd>svn co <a href="https://waterken.svn.sourceforge.net/svnroot/waterken/server/trunk/waterken/config/file/site/">https://waterken.svn.sourceforge.net/svnroot/waterken/server/trunk/waterken/config/file/site/</a></kbd></p>
<p>To bootstrap the web_send library, your server must return HTML code like
that in the
<code><a href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/waterken/config/file/site/example/index.html?view=markup">example/index.html</a></code>
file. This code links in the necessary JavaScript code. For example, if your
application objects are at URLs like:
<code>&lt;https://example.com/myApp/#s=obj123&gt;</code>, you should serve this
HTML from a request to <code>&lt;https://example.com/myApp/&gt;</code>.</p>

<h3><a name="core" href="#core">Core files</a></h3>
<p>The <code>example/index.html</code> file includes lots of example code and
is designed as an <a href="http://adsafe.org/">ADsafe</a> widget. You don't
have to use the ADsafe verifier, or include much of this code. The file
<code><a href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/waterken/config/file/site/minimal/index.html?view=markup">minimal/index.html</a></code>
shows the minimum requirements:</p>
<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script type="text/javascript" src="/site/<span class="highlight">json2.js</span>"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/site/<span class="highlight">adsafe.js</span>"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;noscript&gt;
&lt;p&gt;This page requires a Javascript enabled web browser.&lt;/p&gt;
&lt;/noscript&gt;

&lt;div id="WIDGET_"&gt;
&lt;script type="text/javascript"&gt;
"use strict";
ADSAFE.id('WIDGET_');
&lt;/script&gt;
&lt;script type="text/javascript" src="/site/<span class="highlight">ref_send.js</span>"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/site/<span class="highlight">web_send.js</span>"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
"use strict";
<span class="highlight">ADSAFE.go</span>('WIDGET_', function (dom, lib) {
    /*
     * The ADsafe and web_send libraries are now initialized. Start your
     * application code from here.
     */
});
&lt;/script&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The key components are:</p>
<dl>
<dt>json2.js</dt>
<dd>JSON encoding and decoding</dd>
<dt>adsafe.js</dt>
<dd>HTML manipulation</dd>
<dt>ref_send.js</dt>
<dd>public API for promises</dd>
<dt>web_send.js</dt>
<dd>remote promise implementation</dd>
<dt><code>ADSAFE.go()</code></dt>
<dd>initializes all the libraries</dd>
</dl>

<h2><a name="securityModel" href="#securityModel">Security model</a></h2>
<p>If you do want to make use of the <a href="http://adsafe.org/">ADsafe</a>
verifier, you can use it and the web_send library to constrain the network
access of widgets on your web pages. By default, the ADsafe verifier prevents
any network access by a verified widget. If you allow such a widget to load the
web_send library, it gets permission to send requests using the
<code>window.location</code> URL, and any URL received in a request response.
By controlling what URLs your server returns in its responses, you can control
what URLs the verified widgets can access.</p>
<p>The web_send library also allows clients to navigate the browser window
using any received remote promise. If you wish to allow a widget to message
with a particular server-side object, but not navigate the browser, load the
web_send library in a separate widget which then passes a remote promise to the
more constrained widget. Using this remote promise and the ref_send library,
the more constrained widget can message with the server-side object, but cannot
navigate the browser, since it doesn't have access to the web_send library.</p>

<h2><a name="API" href="#API">API</a></h2>
<p>The API is divided into two parts:
<a href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/waterken/config/file/site/ref_send.js?view=markup">ref_send</a>,
the promise API; and
<a href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/waterken/config/file/site/web_send.js?view=markup">web_send</a>,
the network access API. The public APIs are defined at the bottom of each of
these JavaScript files.</p>

<h3><a name="ref_send" href="#ref_send">ref_send API</a></h3>
<dl class="methods">
<dt><code><a name="Q.run" href="#Q.run">run</a>(task)</code></dt>
<dd>
<span class="comment">Enqueues a task to be run in a future turn.</span>
<dl class="parameters">
<dt><code>task</code></dt>
<dd class="comment">function to invoke later</dd>
</dl>
</dd>
<dt><code><a name="Q.reject" href="#Q.reject">reject</a>(reason, $)</code></dt>
<dd>
<span class="comment">Constructs a rejected promise.</span>
<dl class="parameters">
<dt><code>reason</code></dt>
<dd class="comment">Error object describing the failure</dd>
<dt><code>$</code></dt>
<dd class="comment">optional type info to add to reason</dd>
</dl>
</dd>
<dt><code><a name="Q.ref" href="#Q.ref">ref</a>(value)</code></dt>
<dd>
<span class="comment">Constructs a promise for an immediate reference.</span>
<dl class="parameters">
<dt><code>value</code></dt>
<dd class="comment">immediate reference</dd>
</dl>
</dd>
<dt><code><a name="Q.defer" href="#Q.defer">defer</a>()</code></dt>
<dd>
<div class="comment">
Constructs a ( promise, resolver ) pair.
<p>The resolver is a callback to invoke with a more resolved value for the
promise. To fulfill the promise, simply invoke the resolver with an immediate
reference. To reject the promise, invoke the resolver with the return from a
call to reject(). To put the promise in the same state as another promise,
invoke the resolver with that other promise.</p>
</div>
</dd>
<dt><code><a name="Q.near" href="#Q.near">near</a>(value)</code></dt>
<dd>
<span class="comment">Gets the current value of a promise.</span>
<dl class="parameters">
<dt><code>value</code></dt>
<dd class="comment">promise or immediate reference to evaluate</dd>
</dl>
</dd>
<dt><code><a name="Q.when" href="#Q.when">when</a>(value, fulfilled, rejected)</code></dt>
<dd>
<span class="comment">Registers an observer on a promise.</span>
<dl class="parameters">
<dt><code>value</code></dt>
<dd class="comment">promise or immediate reference to observe</dd>
<dt><code>fulfilled</code></dt>
<dd class="comment">function to be called with the fulfilled value</dd>
<dt><code>rejected</code></dt>
<dd class="comment">function to be called with the rejection reason</dd>
</dl>
<span class="return comment">promise for the return value from the invoked
callback</span>
</dd>
<dt><code><a name="Q.get" href="#Q.get">get</a>(target, q)</code></dt>
<dd>
<span class="comment">Sends a <code>GET</code> request.</span>
<dl class="parameters">
<dt><code>target</code></dt>
<dd class="comment">promise or immediate reference to send request to</dd>
<dt><code>q</code></dt>
<dd class="comment">optional additional query string argument</dd>
</dl>
<span class="return comment">promise for the response entity</span>
</dd>
<dt><code><a name="Q.post" href="#Q.post">post</a>(target, q, entity)</code></dt>
<dd>
<span class="comment">Sends a <code>POST</code> request.</span>
<dl class="parameters">
<dt><code>target</code></dt>
<dd class="comment">promise or immediate reference to send request to</dd>
<dt><code>q</code></dt>
<dd class="comment">optional additional query string argument</dd>
<dt><code>entity</code></dt>
<dd class="comment">optional JSON value for request entity</dd>
</dl>
<span class="return comment">promise for the response entity</span>
</dd>
</dl>

<h3><a name="web_send" href="#web_send">web_send API</a></h3>
<dl class="methods">
<dt><code><a name="web.getLocation" href="#web.getLocation">getLocation</a>()</code></dt>
<dd>
<span class="comment">Gets a promise for the window's current location.</span>
</dd>
<dt><code><a name="web.navigate" href="#web.navigate">navigate</a>(target)</code></dt>
<dd>
<span class="comment">Navigate the window.</span>
<dl class="parameters">
<dt><code>target</code></dt>
<dd class="comment">remote promise for new location</dd>
</dl>
<span class="return comment"><code>true</code> if navigation successful, else
<code>false</code></span>
</dd>
<dt><code><a name="web.href" href="#web.href">href</a>(elements, target)</code></dt>
<dd>
<span class="comment">Sets the 'href' attribute.</span>
<dl class="parameters">
<dt><code>elements</code></dt>
<dd class="comment">bunch of elements to modify</dd>
<dt><code>target</code></dt>
<dd class="comment">remote promise</dd>
</dl>
<span class="return comment"><code>true</code> if attribute set, else
<code>false</code></span>
</dd>
<dt><code><a name="web.src" href="#web.src">src</a>(elements, target)</code></dt>
<dd>
<span class="comment">Sets the 'src' attribute.</span>
<dl class="parameters">
<dt><code>elements</code></dt>
<dd class="comment">bunch of elements to modify</dd>
<dt><code>target</code></dt>
<dd class="comment">remote promise</dd>
</dl>
<span class="return comment"><code>true</code> if attribute set, else
<code>false</code></span>
</dd>
<dt><code><a name="web.getTitle" href="#web.getTitle">getTitle</a>()</code></dt>
<dd>
<span class="comment">Gets the document title.</span>
</dd>
<dt><code><a name="web.setTitle" href="#web.setTitle">setTitle</a>(text)</code></dt>
<dd>
<span class="comment">Sets the document title.</span>
<dl class="parameters">
<dt><code>text</code></dt>
<dd class="comment">new title text</dd>
</dl>
</dd>
<dt><code><a name="web._proxy" href="#web._proxy">_proxy</a>(base, href, args)</code></dt>
<dd>
<span class="comment">Constructs a remote promise.</span>
<dl class="parameters">
<dt><code>base</code></dt>
<dd class="comment">optional remote promise for base URL</dd>
<dt><code>href</code></dt>
<dd class="comment">URLref to wrap</dd>
<dt><code>args</code></dt>
<dd class="comment">optional query argument map</dd>
</dl>
</dd>
<dt><code><a name="web._crack" href="#web._crack">_crack</a>(promise, target)</code></dt>
<dd>
<span class="comment">Extracts the URLref contained within a remote
promise.</span>
<dl class="parameters">
<dt><code>promise</code></dt>
<dd class="comment">remote promise to crack</dd>
<dt><code>target</code></dt>
<dd class="comment">optional remote promise for base URL</dd>
</dl>
<span class="return comment">the URLref, or <code>null</code> if not a remote
promise</span>
</dd>
</dl>

<h2><a name="legacy" href="#legacy">Legacy JSON resources</a></h2>
<p>Though existing JSON resources may not follow the introduced conventions for
<a href="#URLref">URLs</a> and <a href="#JSON">entities</a>, it may still be
more convenient to use the web_send library to interact with them, than it is to
use XMLHttpRequest, or even another wrapper library. This section explains how.

<h3><a name="manual" href="#manual">Construct a promise from a URL</a></h3>
<p>If your JSON doesn't follow the <a href="#JSONlink">JSONlink</a> convention,
you'll have to construct your promises manually, instead of having the web_send
library do it for you automatically. After extracting a URL from a JSON
response, pass it and the request promise to
<a href="#web._proxy">web._proxy</a>(). For example:</p>
<pre>
var page = lib.web.getLocation(); // @ &lt;https://example.com/myApp/&gt;
lib.Q.when(lib.Q.get(page), function (value) {
    var stuff = <span class="highlight">lib.web._proxy(page, value.stuff.url);</span>
    // if stuff.url was "stuff.php", then stuff is
    // &lt;https://example.com/myApp/stuff.php&gt;

    // make a request using the constructed promise
    var moreStuff = lib.Q.get(stuff);
    &hellip;
});
</pre>
<p>You can also augment the URL with query arguments:</p>
<pre>
var stuffArgs = lib.web._proxy(page, value.stuff.url, {
    on: true,
    id: 'P123'
});
</pre>
<p>Extract the URL from a promise with a call to
<a href="web._crack">web._crack</a>(). For example:</p>
<pre>
var url = lib.web._crack(stuffArgs);
// url is &lt;https://example.com/myApp/stuff.php?on=true&amp;id=P123&gt;
</pre>
<p>The extracted URL is an absolute URL, unless you specify an optional
base:</p>
<pre>
var relativeURL = lib.web._crack(stuffArgs, page);
// relativeURL is &lt;./stuff.php?on=true&amp;id=P123&gt;
</pre>

<h3><a name="HTTPerror" href="#HTTPerror">Only HTTP error branch</a></h3>
<p>If your JSON doesn't follow the <a href="#JSONerror">JSONerror</a>
convention, only HTTP level errors will trigger the rejection callback provided
to <a href="#Q.when">Q.when</a>(). All successful HTTP requests are sent to the
fulfilled callback. For example:</p>
<pre>
lib.Q.when(lib.Q.get(stuff), function (value) {
    // value is JSON entity from a success HTTP response
}, function (reason) {
    var status = reason.status; // HTTP status code
    var phrase = reason.phrase; // HTTP reason phrase
});
</pre>

<h2><a name="securityConsiderations" href="#securityConsiderations">Security considerations</a></h2>
<p>For HTTP requests issued by the web_send library, the query component of the
Request-URI contains data contributed by: optional arguments added by the
web_send library (<a href="#q"><code>'q'</code></a>,
<a href="#session"><code>'x'</code> and <code>'w'</code></a>), the query
component of the target promise URLref, and the <a href="#fragment">fragment
component</a> of the target promise URLref. These elements are added to the
Request-URI's query component in that order, which allows a server to
disambiguate them. A request with duplicate query parameters may indicate an
attack. For example, the following code:</p>
<pre>
var target = &hellip;   // @ &lt;https://example.com/myApp?q=foo#q=bar&gt;
lib.Q.post(target, 'baz', []);
</pre>
<p>Generates a <code>POST</code> request to:
<code>&lt;https://example.com/myApp?q=baz&amp;q=foo&amp;q=bar&gt;</code>. In
this case, the server-side code could either: treat only the first
<code>'q'</code> argument as the client specified query string; or reject the
request. When designing the namespace of URLs issued by a web-application,
ensure that the server can always either correctly disambiguate parameters in
the query component of a Request-URI, or reject the request. Keep in mind that
an attacker may send a user a specially crafted URLref that includes unexpected
arguments in the query and fragment components.</p>

<h2><a name="acknowledgments" href="#acknowledgments">Acknowledgments</a></h2>
<p>Thanks to Bill
Frantz, Charles Landau, Chip Morningstar, David-Sarah Hopwood and Mike Samuel
for comments and contributions.</p>

<h2><a name="firebug" href="#firebug">Using the Firebug console</a></h2>
<p>Try out the
<a href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/waterken/config/file/site/web_send.js?view=markup">web_send</a>
library using the <a href="../bang/">Bang Tutorial</a>.</p>

</div>
<p class="footer comment">
<a class="author" href="http://waterken.sourceforge.net/recent.html">Tyler Close</a>,
<a class="date" href="http://waterken.svn.sourceforge.net/viewvc/waterken/server/trunk/www/htdocs/web_send/index.html?view=log">2009-04-29</a>
</p>
</body>
</html>
